#!/usr/bin/env python
from __future__ import division
import argparse
import json
import os
import numpy as np
from phantomas.geometry.fiber import FiberSource
from phantomas.geometry.models import Fiber, IsotropicRegion
from phantomas.mr_simul.partial_volume \
    import (compute_affine_matrix,
            compute_spherical_region_masks,
            compute_fiber_masks,
            compute_volume_fractions)
from phantomas.mr_simul.image_formation \
    import (relaxation_time_images,
            mr_signal,
            rician_noise,
            get_tissue_physical_parameters)
from phantomas.mr_simul.fod \
    import (compute_directions,
            compute_fod,
            compute_fod_sh)
from phantomas.utils import shm
from phantomas.mr_simul.synthetic import GaussianModel
import nibabel as nib
import sys


# Function to check if file exists
def is_valid_file(parser, arg):
    if not os.path.exists(arg):
       parser.error("Cannot open file %s." % arg)
    else:
       return open(arg, 'r')


# The command-line arguments parser.
####################################
description="Compute the voxelwise orientation of fibers. " \


parser = argparse.ArgumentParser(description=description)
parser.add_argument('geometry',
                    type=lambda x: is_valid_file(parser,x),
                    help="A JSON-formatted file describing fiber and phantom "
                         "geometries.")

parser.add_argument('--output_dir', default="./",
                    help="Output directory. (%(default)s)")
parser.add_argument('--output', dest='output', required=False, default="peaks.nii.gz",
                    help="Output peaks file name. (%(default)s)")
parser.add_argument('--nbr_points', type=float, default=100,
                    help="Streamlines sampling. (%(default)s)")
parser.add_argument('--fov', type=float, default=None,
                    help="Field of view in mm. If None, adapts to the size "
                         "of the phantom.")
parser.add_argument('--res', type=float, default=2.0,
                    help="Diffusion-weighted images resolution in mm. (%(default)s)")
parser.add_argument('--export_fod', default=None, metavar='BASIS',
                     help="Either 'dipy' or 'mrtrix': sets the convention of "
                          "the exported FODs.")

args = parser.parse_args()


print "Reading geometry description..."
#######################################
geometry = json.load(args.geometry)

# Read fiber bundles
fibers_dict = geometry.get("fiber_geometries", {})
ts = np.linspace(0, 1., args.nbr_points)
fibers = []
fiber_trajectories = []
fiber_tangents = []
fiber_radii = []
fiber_names = []
for name, fiber_params in fibers_dict.items():
    control_points = np.asarray(fiber_params["control_points"])
    nb_control_points = len(control_points) // 3
    control_points = control_points.reshape((nb_control_points, 3))
    radius = fiber_params["radius"]
    tangents_mode = fiber_params.get("tangents", "symmetric")
    f = FiberSource(control_points, tangents=tangents_mode)
    fiber = Fiber('from_points', points=f(ts), radius=radius)
    fibers.append(fiber)
    fiber_trajectories.append(f(ts))
    fiber_tangents.append(f.tangents(ts))
    #################################
    #################################
    #################################
    fiber_radii.append(radius)# + args.res/2+0.0001)
    fiber_names.append(name)
print "Found %d fibers." % len(fibers)

# Read other phantom parameters
phantom_radius = geometry.get("phantom_radius", None)
if phantom_radius == None:
    fiber = fibers[0].get_points()
    phantom_radius = np.linalg.norm(fiber[0])

phantom_fov = args.fov
if phantom_fov == None:
    phantom_fov = 2.2 * phantom_radius


print "\tComputing mask for each structure."
affine = compute_affine_matrix(args.res, phantom_fov)
phantom_center = np.array([0., 0., 0.])

gm_mask = compute_spherical_region_masks([phantom_center],
                                         [phantom_radius], args.res,
                                         phantom_fov)[..., 0]

fiber_masks = compute_fiber_masks(fibers, args.res, phantom_fov)
for i in range(len(fiber_names)):
    nib.Nifti1Image(fiber_masks[:,:,:,i].astype("float32"),affine).to_filename(args.output_dir + "mask-" + fiber_names[i] + "_" + args.output)



wm_mask = np.any(fiber_masks > 0, axis=-1)
wm_indices = np.nonzero(wm_mask)
resolution = 1
peaks = np.zeros(list(wm_mask.shape) + [15],dtype=np.float32)
for i, j, k in zip(wm_indices[0], wm_indices[1], wm_indices[2]):
    voxel_center = np.dot(affine, np.asarray([i, j, k, 1.0]))[:3]
    fiber_indices = np.nonzero(fiber_masks[i, j, k])[0]
    fod_samples, _ = compute_directions([fiber_trajectories[n] for n in fiber_indices],
                                        [fiber_tangents[n] for n in fiber_indices],
                                        [fiber_radii[n] for n in fiber_indices],
                                        voxel_center,
                                        voxel_size=args.res,
                                        resolution=1)

    for s, sample in enumerate(fod_samples):
        peaks[i,j,k,(s*3):(s*3)+3] = sample
    #fod_weights /= fod_weights.sum()


nib.Nifti1Image(peaks.astype("float32"),affine).to_filename(args.output_dir + args.output)
#nib.Nifti1Image(wm_mask.astype("float32"),affine).to_filename(args.output_dir + "wm_" + args.output)
nib.Nifti1Image(gm_mask.astype("float32"),affine).to_filename(args.output_dir + "sphere_" + args.output)
#import pdb; pdb.set_trace()
